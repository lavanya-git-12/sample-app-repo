# Define substitutions for dynamic values. These will be populated by the trigger.
substitutions:
  _GKE_CLUSTER_NAME: "ci-cd-sample-cluster"
  _GKE_CLUSTER_ZONE: "us-central1-c"
  _ARTIFACT_REGISTRY_REPO: "sample-app-images"
  _APP_CONTAINER_NAME: "sample-app-container" # Matches 'name' in deployment.yaml container spec

steps:
  # Step 1: Build the Docker image
  # Uses the 'docker' Cloud Build builder.
  - name: 'gcr.io/cloud-builders/docker'
    args:
      - 'build'
      #- '-t' # Tag the image
      - '${_GCP_REGION}-docker.pkg.dev/${PROJECT_ID}/${_ARTIFACT_REGISTRY_REPO}/${_APP_CONTAINER_NAME}:${_COMMIT_SHA}'
      - '.' # Build context (current directory, which is 'sample-app' repo root)
    dir: '.' # The Directory where the Dockerfile is relative to the checkout (root of sample-app)

  # Step 2: Push the Docker image to Artifact Registry
  - name: 'gcr.io/cloud-builders/docker'
    args:
      - 'push'
      - '${_GCP_REGION}-docker.pkg.dev/${PROJECT_ID}/${_ARTIFACT_REGISTRY_REPO}/${_APP_CONTAINER_NAME}:${_COMMIT_SHA}'
    dir: '.'

  # Step 3: Get credentials for the GKE cluster
  # This makes 'kubectl' able to communicate with your GKE cluster.
  - name: 'gcr.io/cloud-builders/gcloud'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        gcloud container clusters get-credentials "${_GKE_CLUSTER_NAME}" \
          --zone "${_GKE_CLUSTER_ZONE}" \
          --project="${PROJECT_ID}"

  # Step 4: Deploy Kubernetes Service (if not exists) and ensure it's up-to-date
  # Use 'apply' which is idempotent (creates if not exists, updates if changed)
  - name: 'gcr.io/cloud-builders/kubectl'
    args:
      - 'apply'
      - '-f'
      - 'kubernetes/service.yaml' # Path to your service manifest
    env:
      - "CLOUDSDK_CONTAINER_CLUSTER=${_GKE_CLUSTER_NAME}"
      - "CLOUDSDK_COMPUTE_ZONE=${_GKE_CLUSTER_ZONE}"
    dir: '.' # kubectl works from the repo root

  # Step 5: Update the Kubernetes Deployment with the new image
  # Uses 'set image' to update the container image in the deployment.
  - name: 'gcr.io/cloud-builders/kubectl'
    args:
      - 'set'
      - 'image'
      - 'deployment/sample-app' # Name of your Deployment from deployment.yaml
      - '${_APP_CONTAINER_NAME}=${_GCP_REGION}-docker.pkg.dev/${PROJECT_ID}/${_ARTIFACT_REGISTRY_REPO}/${_APP_CONTAINER_NAME}:${_COMMIT_SHA}'
      - '--record=true' # Keep a record of the change in Deployment history
    env:
      - "CLOUDSDK_CONTAINER_CLUSTER=${_GKE_CLUSTER_NAME}"
      - "CLOUDSDK_COMPUTE_ZONE=${_GKE_CLUSTER_ZONE}"
    dir: '.' # kubectl works from the repo root

# This section lists the images produced by this build (optional, but good practice)
images:
  - '${_GCP_REGION}-docker.pkg.dev/${PROJECT_ID}/${_ARTIFACT_REGISTRY_REPO}/${_APP_CONTAINER_NAME}:${_COMMIT_SHA}'

